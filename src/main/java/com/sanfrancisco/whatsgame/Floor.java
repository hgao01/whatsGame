package com.sanfrancisco.whatsgame;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import javax.microedition.khronos.opengles.GL10;

import static com.sanfrancisco.whatsgame.Constant.*;

//???a?O?????O
public class Floor {
    private FloatBuffer mVertexBuffer;//???I?y????w?R
    private FloatBuffer mNormalBuffer;//???I?k?V?q???w?R
    private FloatBuffer mTextureBuffer;//???I???z???w?R
    int vCount = 0;//???I??q
    float yAngle;//y?b??????
    int xOffset;//x?????q
    int zOffset;//z?????q
    int texId;//???zID
    int width;//?a?O????width????
    int height;//?a?O???Lheight????

    public Floor(int xOffset, int zOffset, float scale, float yAngle, int texId, int width, int height) {
        this.xOffset = xOffset;
        this.zOffset = zOffset;
        this.yAngle = yAngle;
        this.texId = texId;
        this.width = width;
        this.height = height;

        //???I?y??????_?l??================begin============================
        vCount = width * height * 6;//?C??a?O??6????I

        float vertices[] = new float[vCount * 3];
        int k = 0;
        for (int i = 0; i < width; i++)
            for (int j = 0; j < height; j++) {//?C??a?O??????T????6????I?c??
                vertices[k++] = i * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = j * UNIT_SIZE * scale;
                vertices[k++] = i * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = (j + 1) * UNIT_SIZE * scale;
                vertices[k++] = (i + 1) * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = (j + 1) * UNIT_SIZE * scale;

                vertices[k++] = (i + 1) * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = (j + 1) * UNIT_SIZE * scale;
                vertices[k++] = (i + 1) * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = j * UNIT_SIZE * scale;
                vertices[k++] = i * UNIT_SIZE * scale;
                vertices[k++] = 0;
                vertices[k++] = j * UNIT_SIZE * scale;
            }
        ;

        //?????I?y????w?R
        //vertices.length*4?O?]???@??Float?|?????
        ByteBuffer vbb = ByteBuffer.allocateDirect(vertices.length * 4);
        vbb.order(ByteOrder.nativeOrder());//?]?w???????
        mVertexBuffer = vbb.asFloatBuffer();//??int???w?R
        mVertexBuffer.put(vertices);//?V?w?R?????J???I?y????
        mVertexBuffer.position(0);//?]?w?w?R??_?l??m
        //?S?O????G???P???x?????????P???????O??????@?w?n?g??ByteBuffer
        //???A????O?n?z?LByteOrder?]?wnativeOrder()?A?_?h???i??|?X???D
        //???I?y??????_?l??================end============================

        //???I?k?V?q?????_?l??================begin============================
        float normals[] = new float[vCount * 3];
        for (int i = 0; i < vCount; i++) {
            normals[i * 3] = 0;
            normals[i * 3 + 1] = 1;
            normals[i * 3 + 2] = 0;
        }

        ByteBuffer nbb = ByteBuffer.allocateDirect(normals.length * 4);
        nbb.order(ByteOrder.nativeOrder());//?]?w???????
        mNormalBuffer = nbb.asFloatBuffer();//??int???w?R
        mNormalBuffer.put(normals);//?V?w?R?????J???I?????
        mNormalBuffer.position(0);//?]?w?w?R??_?l??m
        //?S?O????G???P???x?????????P???????O??????@?w?n?g??ByteBuffer
        //???A????O?n?z?LByteOrder?]?wnativeOrder()?A?_?h???i??|?X???D
        //???I???????_?l??================end============================

        //???z ?y????_?l??
        float[] texST = new float[vCount * 2];
        for (int i = 0; i < vCount * 2 / 12; i++) {
            texST[i * 12] = 0;
            texST[i * 12 + 1] = 0;

            texST[i * 12 + 2] = 0;
            texST[i * 12 + 3] = 2;

            texST[i * 12 + 4] = 2;
            texST[i * 12 + 5] = 2;

            texST[i * 12 + 6] = 2;
            texST[i * 12 + 7] = 2;

            texST[i * 12 + 8] = 2;
            texST[i * 12 + 9] = 0;

            texST[i * 12 + 10] = 0;
            texST[i * 12 + 11] = 0;
        }
        ;
        ByteBuffer tbb = ByteBuffer.allocateDirect(texST.length * 4);
        tbb.order(ByteOrder.nativeOrder());//?]?w???????
        mTextureBuffer = tbb.asFloatBuffer();//??int???w?R
        mTextureBuffer.put(texST);//?V?w?R?????J???I?????
        mTextureBuffer.position(0);//?]?w?w?R??_?l??m
    }

    public void drawSelf(GL10 gl) {
        gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);//?????I?y??}?C
        gl.glEnableClientState(GL10.GL_NORMAL_ARRAY);//?????I?k?V?q?}?C

        gl.glPushMatrix();//?O?@?{??
        gl.glTranslatef(xOffset * UNIT_SIZE, 0, 0);
        gl.glTranslatef(0, 0, zOffset * UNIT_SIZE);
        gl.glRotatef(yAngle, 0, 1, 0);

        //???e?????w???I?y????
        gl.glVertexPointer
                (
                        3,                //?C????I???y???q??3  xyz
                        GL10.GL_FLOAT,    //???I?y???????A?? GL_FIXED
                        0,                //?s???I?y????????????j
                        mVertexBuffer    //???I?y????
                );

        //???e?????w???I?k?V?q???
        gl.glNormalPointer(GL10.GL_FLOAT, 0, mNormalBuffer);

        //?}????z
        gl.glEnable(GL10.GL_TEXTURE_2D);
        //?e?\?????zST?y??w?R
        gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);
        //???e?????w???zST?y??w?R
        gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, mTextureBuffer);
        //?j?w??e???z
        gl.glBindTexture(GL10.GL_TEXTURE_2D, texId);

        //?????
        gl.glDrawArrays
                (
                        GL10.GL_TRIANGLES,        //?H?T????????R
                        0,                        //?}?l?I?s??
                        vCount                    //???I????q
                );

        gl.glPopMatrix();//???{??
    }
}
